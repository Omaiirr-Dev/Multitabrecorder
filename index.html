<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Screen Recorder</title>
    <!-- External CSS -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>Multi-Screen Recorder</h1>
        
        <div class="card">
            <h2>Screen Recording Controls</h2>
            
            <div class="input-group">
                <label for="duration">Recording Duration (seconds):</label>
                <input type="number" id="duration" value="1800" min="5" max="7200">
            </div>
            
            <div class="input-group">
                <label for="video-format">Video Format:</label>
                <select id="video-format">
                    <option value="webm">WebM (Best for web)</option>
                    <option value="mp4">MP4</option>
                    <option value="mkv">MKV</option>
                    <option value="avi">AVI</option>
                </select>
            </div>
            
            <div class="input-group">
                <label for="video-quality">Video Quality:</label>
                <div class="quality-slider-container">
                    <input type="range" id="video-quality" class="quality-slider" min="0" max="4" value="0" step="1">
                    <div class="quality-display">
                        <span id="quality-text">4K Ultra</span>
                    </div>
                </div>
            </div>
            
            <div class="input-group">
                <label for="auto-save">Auto-save to device:</label>
                <button id="auto-save" class="toggle-btn" data-enabled="true">
                    <span class="toggle-text">ON</span>
                </button>
            </div>
            
            <div class="button-group">
                <button id="add-screen-btn" class="btn-success" onclick="addScreenRecording()">Share Screen & Record</button>
                <button id="stop-all-btn" class="btn-danger" onclick="stopAllRecordings()" disabled>Stop All Recordings</button>
            </div>
        </div>
        
        <div class="card">
            <h2>Active Screen Recordings</h2>
            <div id="recordings-preview" class="stream-urls-container">
                No screen recordings active
            </div>
        </div>
        
        <div class="card">
            <h2>Recording Status</h2>
            <div id="overall-status" class="status-display">Ready to record</div>
            <div id="individual-statuses"></div>
        </div>
        
        <div class="card">
            <h2>Recorded Videos</h2>
            <div class="button-group" style="margin-bottom: 15px;">
                <button class="btn-danger" onclick="clearAllSavedRecordings()">Delete All Saved Videos</button>
            </div>
            <div id="recordings-list" class="recordings-list">
                <p>No recordings yet. Start recording to see your videos here.</p>
            </div>
        </div>
    </div>

    <script>
        // Basic app settings - nothing fancy here!
        const CONFIG = {
            MAX_RECORDING_DURATION: 7200000, // 2 hours max - should be plenty!
            SCREENSHOT_INTERVALS: {
                MIN: 2000, // grab a screenshot every 2 seconds
                MAX: 6000  // or every 6 seconds depending on performance
            },
            PREVIEW_DIMENSIONS: {
                WIDTH: 220,  // preview video size
                HEIGHT: 130
            },
            THUMBNAIL_DIMENSIONS: {
                WIDTH: 160,  // thumbnail size for saved videos
                HEIGHT: 90
            },
            STORAGE_KEYS: {
                RECORDINGS: 'webRecordings',      // where we save recordings
                USER_PREFERENCES: 'userPreferences' // user settings
            },
            ERROR_RECOVERY_ATTEMPTS: 3, // try 3 times if something fails
            CLEANUP_DELAY: 100          // wait a bit before cleaning up
        };

        // Main class that handles all the recording stuff
        class RecordingStateManager {
            constructor() {
                this.screenRecordings = new Map();  // active recordings
                this.recordingCounter = 0;          // count how many we've made
                this.statusUpdateInterval = null;   // timer for updating UI
                this.autoSaveEnabled = true;        // save files automatically
                this.thumbnailCaptures = new Map();  // screenshot data
                this.errorHandlers = new Map();      // error handling
                this.cleanup = this.cleanup.bind(this);
                
                // Load user's saved preferences
                this.loadUserPreferences();
                this.initializeEventListeners();
                this.initializeQualitySlider();
            }

            loadUserPreferences() {
                try {
                    const preferences = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.USER_PREFERENCES) || '{}');
                    this.autoSaveEnabled = preferences.autoSave !== undefined ? preferences.autoSave : true;
                    
                    // Update the toggle button to match saved setting
                    this.updateToggleButton();
                } catch (error) {
                    console.error('Oops, couldn\'t load your preferences:', error);
                    this.autoSaveEnabled = true;
                    this.updateToggleButton();
                }
            }

            updateToggleButton() {
                const toggleBtn = document.getElementById('auto-save');
                const toggleText = toggleBtn?.querySelector('.toggle-text');
                
                if (toggleBtn && toggleText) {
                    toggleBtn.setAttribute('data-enabled', this.autoSaveEnabled.toString());
                    toggleText.textContent = this.autoSaveEnabled ? 'ON' : 'OFF';
                }
            }

            saveUserPreferences() {
                try {
                    const preferences = {
                        autoSave: this.autoSaveEnabled,
                        timestamp: new Date().toISOString()
                    };
                    localStorage.setItem(CONFIG.STORAGE_KEYS.USER_PREFERENCES, JSON.stringify(preferences));
                } catch (error) {
                    console.error('Couldn\'t save your preferences:', error);
                }
            }

            initializeEventListeners() {
                // Listen for auto-save toggle clicks
                const autoSaveToggle = document.getElementById('auto-save');
                if (autoSaveToggle) {
                    autoSaveToggle.addEventListener('click', this.handleAutoSaveToggle.bind(this));
                }
                
                // Clean up when page closes
                window.addEventListener('beforeunload', this.cleanup);
                window.addEventListener('unload', this.cleanup);
            }

            initializeQualitySlider() {
                const qualitySlider = document.getElementById('video-quality');
                const qualityText = document.getElementById('quality-text');
                const qualityNames = ['4K Ultra', '1440p QHD', '1080p Full HD', '720p HD', '480p SD'];
                
                if (qualitySlider && qualityText) {
                    qualitySlider.addEventListener('input', (e) => {
                        const value = parseInt(e.target.value);
                        qualityText.textContent = qualityNames[value] || '4K Ultra';
                    });
                }
            }

            handleAutoSaveToggle() {
                this.autoSaveEnabled = !this.autoSaveEnabled;
                this.updateToggleButton();
                this.saveUserPreferences();
                
                const message = this.autoSaveEnabled ? 
                    'Auto-save enabled - recordings will download automatically' : 
                    'Auto-save disabled - you\'ll need to manually download recordings';
                this.showAlert(message);
            }

            cleanup() {
                // Stop all active recordings when leaving the page
                this.screenRecordings.forEach((recording, id) => {
                    try {
                        if (recording.mediaRecorder && recording.mediaRecorder.state !== 'inactive') {
                            recording.mediaRecorder.stop();
                        }
                        if (recording.stream) {
                            recording.stream.getTracks().forEach(track => {
                                try {
                                    track.stop();
                                } catch (e) {
                                    console.warn('Error stopping track:', e);
                                }
                            });
                        }
                    } catch (error) {
                        console.warn('Error during cleanup:', error);
                    }
                });
                
                // Clear the status update timer
                if (this.statusUpdateInterval) {
                    clearInterval(this.statusUpdateInterval);
                    this.statusUpdateInterval = null;
                }
            }

            showAlert(message, type = 'success') {
                try {
                    // Create a nice popup message
                    const alertDiv = document.createElement('div');
                    alertDiv.className = `alert alert-${type}`;
                    alertDiv.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        padding: 15px 20px;
                        border-radius: 5px;
                        color: white;
                        font-weight: bold;
                        z-index: 10000;
                        max-width: 400px;
                        word-wrap: break-word;
                        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                        transition: all 0.3s ease;
                        background-color: ${type === 'error' ? '#e74c3c' : '#27ae60'};
                    `;
                    alertDiv.textContent = message;
                    
                    document.body.appendChild(alertDiv);
                    
                    // Fade out and remove after 5 seconds
                    setTimeout(() => {
                        alertDiv.style.opacity = '0';
                        alertDiv.style.transform = 'translateX(100%)';
                        setTimeout(() => {
                            if (alertDiv.parentNode) {
                                alertDiv.remove();
                            }
                        }, 300);
                    }, 4700);
                } catch (error) {
                    console.error('Error showing alert:', error);
                }
            }
        }

        // Handles taking screenshots during recording
        class ThumbnailCaptureEngine {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.captureQueue = new Map();
            }

            async initializeThumbnailCapture(stream, recordingId) {
                try {
                    // Create a hidden video element to capture frames from
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.autoplay = true;
                    video.muted = true;
                    video.playsInline = true;
                    video.style.position = 'absolute';
                    video.style.left = '-9999px';
                    video.style.top = '-9999px';
                    video.style.width = '1px';
                    video.style.height = '1px';
                    
                    // Add to page so it actually loads
                    document.body.appendChild(video);

                    return new Promise((resolve, reject) => {
                        const timeoutId = setTimeout(() => {
                            reject(new Error('Video took too long to load'));
                        }, 10000);

                        video.onloadedmetadata = async () => {
                            clearTimeout(timeoutId);
                            try {
                                await video.play();
                                
                                // Wait for the first frame to be ready
                                await new Promise(resolve => setTimeout(resolve, 1000));
                                
                                const captureData = {
                                    video,
                                    stream,
                                    recordingId,
                                    isActive: true,
                                    captureCount: 0,
                                    lastCapture: null
                                };

                                this.stateManager.thumbnailCaptures.set(recordingId, captureData);
                                this.startContinuousCapture(captureData);
                                resolve(captureData);
                            } catch (playError) {
                                clearTimeout(timeoutId);
                                document.body.removeChild(video);
                                reject(playError);
                            }
                        };

                        video.onerror = () => {
                            clearTimeout(timeoutId);
                            document.body.removeChild(video);
                            reject(new Error('Video failed to load'));
                        };
                    });
                } catch (error) {
                    console.error('Error setting up thumbnail capture:', error);
                    throw error;
                }
            }

            startContinuousCapture(captureData) {
                const captureFrame = () => {
                    // Stop if recording is done
                    if (!captureData.isActive || !this.stateManager.screenRecordings.has(captureData.recordingId)) {
                        this.stopCapture(captureData.recordingId);
                        return;
                    }

                    try {
                        const { video } = captureData;
                        
                        // Make sure video is actually playing and has content
                        if (video.videoWidth > 0 && video.videoHeight > 0 && !video.paused) {
                            // Set up canvas for screenshot
                            this.canvas.width = CONFIG.THUMBNAIL_DIMENSIONS.WIDTH;
                            this.canvas.height = CONFIG.THUMBNAIL_DIMENSIONS.HEIGHT;
                            
                            // Figure out how to fit the video in the thumbnail
                            const videoAspect = video.videoWidth / video.videoHeight;
                            const canvasAspect = this.canvas.width / this.canvas.height;
                            
                            let sx = 0, sy = 0, sw = video.videoWidth, sh = video.videoHeight;
                            
                            if (videoAspect > canvasAspect) {
                                // Video is wider - crop the sides
                                sw = video.videoHeight * canvasAspect;
                                sx = (video.videoWidth - sw) / 2;
                            } else {
                                // Video is taller - crop top/bottom
                                sh = video.videoWidth / canvasAspect;
                                sy = (video.videoHeight - sh) / 2;
                            }
                            
                            // Draw the frame
                            this.ctx.fillStyle = '#000000';
                            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                            
                            this.ctx.drawImage(
                                video, 
                                sx, sy, sw, sh,
                                0, 0, this.canvas.width, this.canvas.height
                            );
                            
                            // Add a slight overlay to make it look like a thumbnail
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                            
                            // Save the screenshot
                            const thumbnail = this.canvas.toDataURL('image/jpeg', 0.8);
                            captureData.lastCapture = thumbnail;
                            captureData.captureCount++;
                        }
                    } catch (error) {
                        console.warn('Error capturing frame:', error);
                    }
                    
                    // Schedule next capture
                    const nextInterval = CONFIG.SCREENSHOT_INTERVALS.MIN + 
                        Math.random() * (CONFIG.SCREENSHOT_INTERVALS.MAX - CONFIG.SCREENSHOT_INTERVALS.MIN);
                    captureData.timeoutId = setTimeout(captureFrame, nextInterval);
                };
                
                // Start capturing after a short delay
                captureData.timeoutId = setTimeout(captureFrame, 2000);
            }

            stopCapture(recordingId) {
                const captureData = this.stateManager.thumbnailCaptures.get(recordingId);
                if (captureData) {
                    captureData.isActive = false;
                    
                    if (captureData.timeoutId) {
                        clearTimeout(captureData.timeoutId);
                    }
                    
                    if (captureData.video) {
                        captureData.video.srcObject = null;
                        if (captureData.video.parentNode) {
                            captureData.video.parentNode.removeChild(captureData.video);
                        }
                    }
                    
                    this.stateManager.thumbnailCaptures.delete(recordingId);
                }
            }
        }

        // This function sets up video quality based on what the user picked
        function getVideoConstraints(qualityValue) {
            const constraints = {
                video: {
                    frameRate: { ideal: 60, max: 60 }  // Higher framerate for smoother video
                }
            };
            
            // Convert slider value to quality setting
            const qualityMap = {
                0: '4k',
                1: '1440p', 
                2: '1080p',
                3: '720p',
                4: '480p'
            };
            
            const quality = qualityMap[qualityValue] || '4k';
            
            // Set resolution based on quality choice
            switch (quality) {
                case '4k':
                    constraints.video.width = { ideal: 3840 };
                    constraints.video.height = { ideal: 2160 };
                    break;
                case '1440p':
                    constraints.video.width = { ideal: 2560 };
                    constraints.video.height = { ideal: 1440 };
                    break;
                case '1080p':
                    constraints.video.width = { ideal: 1920 };
                    constraints.video.height = { ideal: 1080 };
                    break;
                case '720p':
                    constraints.video.width = { ideal: 1280 };
                    constraints.video.height = { ideal: 720 };
                    break;
                case '480p':
                    constraints.video.width = { ideal: 854 };
                    constraints.video.height = { ideal: 480 };
                    break;
            }
            
            return constraints;
        }

        function updateRecordingsPreview() {
            const previewContainer = document.getElementById('recordings-preview');
            
            if (stateManager.screenRecordings.size === 0) {
                previewContainer.innerHTML = 'No screen recordings active';
                document.getElementById('stop-all-btn').disabled = true;
                return;
            }
            
            previewContainer.innerHTML = '';
            document.getElementById('stop-all-btn').disabled = false;
            
            // Show each active recording
            stateManager.screenRecordings.forEach((recording, id) => {
                const recordingItem = document.createElement('div');
                recordingItem.className = 'recording-status-item recording';
                recordingItem.innerHTML = `
                    <div style="flex: 1;">
                        <div class="url-label">${recording.tabTitle || 'Screen Recording'} ${id}</div>
                        <div class="status-text">Recording... ${formatTime((Date.now() - recording.startTime) / 1000)} elapsed</div>
                    </div>
                    <div class="recording-preview-container">
                        <video id="preview-${id}" class="preview-video" autoplay muted playsinline></video>
                        <div class="preview-overlay">
                            <div class="recording-indicator">
                                <div class="recording-dot"></div>
                                REC
                            </div>
                        </div>
                    </div>
                    <button class="remove-btn" onclick="stopScreenRecording(${id})">Stop</button>
                `;
                previewContainer.appendChild(recordingItem);
                
                // Show live preview of what's being recorded
                setTimeout(() => {
                    const video = document.getElementById(`preview-${id}`);
                    if (video && recording.stream) {
                        video.srcObject = recording.stream;
                        // Make sure it plays on all browsers
                        video.play && video.play().catch(() => {});
                    }
                }, 100);
            });
        }

        // Main function that starts screen recording
        async function addScreenRecording() {
            try {
                // Check if browser supports screen recording
                if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                    stateManager.showAlert('Your browser doesn\'t support screen recording. Try Chrome, Edge, or Firefox.', 'error');
                    return;
                }
                if (typeof MediaRecorder === 'undefined') {
                    stateManager.showAlert('MediaRecorder not available in this browser.', 'error');
                    return;
                }

                const selectedQuality = parseInt(document.getElementById('video-quality').value);
                const constraints = getVideoConstraints(selectedQuality);
                // Show cursor in recordings
                constraints.video.cursor = 'always';

                // Ask user to pick what to record - simple and clean
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: constraints.video,
                    audio: true
                });

                if (!stream || stream.getVideoTracks().length === 0) {
                    stateManager.showAlert('No video captured. Please try again and pick a tab.', 'error');
                    return;
                }

                const recordingId = ++stateManager.recordingCounter;
                const duration = parseInt(document.getElementById('duration').value) * 1000;

                // Try to get a nice name for what we're recording
                let tabTitle = 'Screen Recording';
                try {
                    const label = stream.getVideoTracks()[0]?.label || '';
                    if (label.includes('tab:')) {
                        tabTitle = label.split('tab:')[1].trim();
                    } else if (label) {
                        tabTitle = label.trim();
                    }
                    tabTitle = tabTitle.replace(/[^\w\s-]/g, '').substring(0, 50) || 'Screen Recording';
                } catch {}

                // Set up thumbnail capture
                try {
                    await thumbnailEngine.initializeThumbnailCapture(stream, recordingId);
                } catch (thumbnailError) {
                    console.warn('Thumbnail capture setup failed:', thumbnailError);
                }

                const qualityNames = ['4K Ultra', '1440p QHD', '1080p Full HD', '720p HD', '480p SD'];
                const qualityName = qualityNames[selectedQuality] || '4K Ultra';
                
                startScreenRecording(stream, recordingId, duration, tabTitle);
                stateManager.showAlert(`Started recording in ${qualityName} quality!`);

            } catch (error) {
                console.error('Error starting recording:', error);
                let errorMessage = 'Failed to start recording. ';
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Please allow screen sharing and pick a tab.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No sharing source available.';
                } else if (error.name === 'TypeError') {
                    errorMessage += 'Try serving this page over http(s) (localhost works fine).';
                } else {
                    errorMessage += 'Please try again.';
                }
                stateManager.showAlert(errorMessage, 'error');
            }
        }

        // Fixed stop function - now properly stops everything
        function stopScreenRecording(recordingId) {
            const recording = stateManager.screenRecordings.get(recordingId);
            if (!recording) {
                console.warn('Recording not found:', recordingId);
                return;
            }

            try {
                // Capture final thumbnail before stopping
                const thumbnailData = stateManager.thumbnailCaptures.get(recordingId);
                if (thumbnailData && thumbnailData.video && thumbnailData.video.videoWidth > 0) {
                    try {
                        thumbnailEngine.captureFinalThumbnail(recordingId);
                    } catch (error) {
                        console.warn('Final thumbnail capture failed:', error);
                    }
                }
                
                // Stop the media recorder first
                if (recording.mediaRecorder && recording.mediaRecorder.state !== 'inactive') {
                    recording.mediaRecorder.stop();
                }
                
                // Stop all tracks in the stream (this kills the live feed)
                if (recording.stream) {
                    recording.stream.getTracks().forEach(track => {
                        try {
                            track.stop();
                        } catch (error) {
                            console.warn('Error stopping track:', error);
                        }
                    });
                }
                
                // Remove from active recordings immediately
                stateManager.screenRecordings.delete(recordingId);
                
                // Clean up thumbnail capture
                setTimeout(() => {
                    thumbnailEngine.stopCapture(recordingId);
                }, 100);
                
                // Update UI immediately
                updateRecordingsPreview();
                updateStatusDisplay();
                
                stateManager.showAlert(`Recording ${recordingId} stopped successfully`);
                
            } catch (error) {
                console.error('Error stopping recording:', error);
                stateManager.showAlert(`Error stopping recording ${recordingId}`, 'error');
            }
        }

        function startStatusUpdates() {
            if (stateManager.statusUpdateInterval) {
                clearInterval(stateManager.statusUpdateInterval);
            }
            
            stateManager.statusUpdateInterval = setInterval(updateStatusDisplay, 1000);
        }

        function stopStatusUpdates() {
            if (stateManager.statusUpdateInterval) {
                clearInterval(stateManager.statusUpdateInterval);
                stateManager.statusUpdateInterval = null;
            }
        }

        function updateStatusDisplay() {
            const overallStatus = document.getElementById('overall-status');
            const individualStatuses = document.getElementById('individual-statuses');
            
            if (stateManager.screenRecordings.size === 0) {
                overallStatus.textContent = 'Ready to record screens';
                overallStatus.classList.remove('recording-active');
                individualStatuses.innerHTML = '';
                stopStatusUpdates();
                return;
            }
            
            overallStatus.textContent = `Recording ${stateManager.screenRecordings.size} screens...`;
            overallStatus.classList.add('recording-active');
            
            // Update individual statuses
            individualStatuses.innerHTML = '';
            stateManager.screenRecordings.forEach((recording, id) => {
                const statusItem = document.createElement('div');
                statusItem.className = 'recording-status-item recording';
                
                const recordingElapsed = (Date.now() - recording.startTime) / 1000;
                const remaining = Math.max(0, (recording.duration / 1000) - recordingElapsed);
                
                statusItem.innerHTML = `
                    <div class="url-label">${recording.tabTitle || 'Screen Recording'} ${id}</div>
                    <div class="status-text">Recording... ${formatTime(recordingElapsed)} elapsed, ${formatTime(remaining)} remaining</div>
                `;
                
                individualStatuses.appendChild(statusItem);
            });
            
            updateRecordingsPreview();
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function startScreenRecording(stream, recordingId, duration, tabTitle = "Unknown") {
            const selectedFormat = document.getElementById('video-format').value;
            let options = {};
            
            // Set MIME type based on selected format with fallbacks
            switch(selectedFormat) {
                case 'mp4':
                    options.mimeType = 'video/mp4';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm'; // Fallback
                    }
                    break;
                case 'mkv':
                    options.mimeType = 'video/x-matroska';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm'; // Fallback
                    }
                    break;
                case 'avi':
                    options.mimeType = 'video/avi';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm'; // Fallback
                    }
                    break;
                default: // webm
                    options.mimeType = 'video/webm;codecs=vp9,opus';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm;codecs=vp8,opus';
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            options.mimeType = 'video/webm';
                        }
                    }
            }
            
            const mediaRecorder = new MediaRecorder(stream, options);
            const recordedChunks = [];
            const startTime = Date.now();
            
            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = function() {
                // Save the recording data
                saveScreenRecording(recordedChunks, recordingId, startTime, tabTitle);
                
                // Clean up the recording from active list
                setTimeout(() => {
                    stateManager.screenRecordings.delete(recordingId);
                    thumbnailEngine.stopCapture(recordingId);
                    updateRecordingsPreview();
                    updateStatusDisplay();
                }, CONFIG.CLEANUP_DELAY);
            };

            // Handle stream ending (user stops sharing)
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                if (mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
            });
            
            mediaRecorder.start(1000);
            
            stateManager.screenRecordings.set(recordingId, {
                mediaRecorder,
                stream,
                startTime,
                duration,
                tabTitle,
                screenshot: null
            });
            
            // Auto-stop after duration
            setTimeout(() => {
                if (stateManager.screenRecordings.has(recordingId)) {
                    stopScreenRecording(recordingId);
                }
            }, duration);
            
            updateRecordingsPreview();
            startStatusUpdates();
        }

        function saveScreenRecording(recordedChunks, recordingId, startTime, tabTitle = "Unknown") {
            if (recordedChunks.length === 0) {
                stateManager.showAlert(`No recording data to save for screen ${recordingId}`, 'error');
                return;
            }
            
            const selectedFormat = document.getElementById('video-format').value;
            const qualitySlider = document.getElementById('video-quality');
            const qualityValues = ['4k', '1440p', '1080p', '720p', '480p'];
            const selectedQuality = qualityValues[parseInt(qualitySlider.value)];
            const autoSave = stateManager.autoSaveEnabled;
            const mimeType = getMimeTypeForFormat(selectedFormat);
            const blob = new Blob(recordedChunks, { type: mimeType });
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            
            // Clean tab title for filename (remove special characters)
            const cleanTabTitle = tabTitle.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
            
            // Get count of recordings with the same tab title
            const recordings = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.RECORDINGS) || '[]');
            const sameTabCount = recordings.filter(rec => 
                rec.tabTitle && rec.tabTitle.toLowerCase() === tabTitle.toLowerCase()
            ).length + 1;
            
            const filename = `${cleanTabTitle}_${sameTabCount}_${selectedQuality}.${selectedFormat}`;
            const duration = (Date.now() - startTime) / 1000;
            
            // Save to localStorage for persistence
            const reader = new FileReader();
            reader.onload = function() {
                const recordings = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.RECORDINGS) || '[]');
                
                // Get screenshot from active recording or thumbnail capture
                let screenshot = null;
                const activeRecording = stateManager.screenRecordings.get(recordingId);
                const thumbnailData = stateManager.thumbnailCaptures.get(recordingId);
                
                if (activeRecording && activeRecording.screenshot) {
                    screenshot = activeRecording.screenshot;
                } else if (thumbnailData && thumbnailData.lastCapture) {
                    screenshot = thumbnailData.lastCapture;
                }
                
                recordings.push({
                    filename: filename,
                    data: reader.result,
                    size: blob.size,
                    timestamp: new Date().toISOString(),
                    duration: duration,
                    sourceUrl: `${tabTitle} ${recordingId}`,
                    streamIndex: recordingId,
                    format: selectedFormat,
                    quality: selectedQuality,
                    tabTitle: tabTitle,
                    tabCount: sameTabCount,
                    screenshot: screenshot
                });
                
                localStorage.setItem(CONFIG.STORAGE_KEYS.RECORDINGS, JSON.stringify(recordings));
                loadSavedRecordings();
                
                // Auto-save to device if enabled
                if (autoSave) {
                    try {
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(a.href);
                        stateManager.showAlert(`Screen recording ${recordingId} auto-saved to your device`);
                    } catch (downloadError) {
                        console.error('Auto-save failed:', downloadError);
                        stateManager.showAlert(`Recording saved but auto-download failed: ${filename}`, 'error');
                    }
                } else {
                    stateManager.showAlert(`Screen recording ${recordingId} saved: ${filename}`);
                }
            };
            
            reader.onerror = function() {
                stateManager.showAlert(`Failed to save recording ${recordingId}`, 'error');
            };
            
            reader.readAsDataURL(blob);
        }

        function getMimeTypeForFormat(format) {
            switch(format) {
                case 'mp4': return 'video/mp4';
                case 'mkv': return 'video/x-matroska';
                case 'avi': return 'video/avi';
                default: return 'video/webm';
            }
        }

        function stopAllRecordings() {
            stateManager.screenRecordings.forEach((recording, id) => {
                if (recording.mediaRecorder && recording.mediaRecorder.state !== 'inactive') {
                    recording.mediaRecorder.stop();
                }
                if (recording.stream) {
                    recording.stream.getTracks().forEach(track => track.stop());
                }
                thumbnailEngine.stopCapture(id);
            });
            
            stateManager.showAlert('All screen recordings stopped');
        }

        function clearAllRecordings() {
            if (stateManager.screenRecordings.size > 0) {
                stateManager.showAlert('Cannot clear while recordings are active', 'error');
                return;
            }
            updateRecordingsPreview();
            stateManager.showAlert('All recordings cleared');
        }

        function clearAllSavedRecordings() {
            localStorage.removeItem(CONFIG.STORAGE_KEYS.RECORDINGS);
            loadSavedRecordings();
            stateManager.showAlert('All saved recordings deleted');
        }

        function loadSavedRecordings() {
            const recordings = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.RECORDINGS) || '[]');
            const recordingsList = document.getElementById('recordings-list');
            
            if (recordings.length === 0) {
                recordingsList.innerHTML = '<p>No recordings yet. Start recording to see your videos here.</p>';
                return;
            }
            
            recordingsList.innerHTML = '';
            
            recordings.reverse().forEach((recording, index) => {
                const recordingDiv = document.createElement('div');
                recordingDiv.className = 'recording-item';
                
                const sizeInMB = (recording.size / (1024 * 1024)).toFixed(2);
                const date = new Date(recording.timestamp).toLocaleString();
                const sourceInfo = `${recording.format?.toUpperCase() || 'WEBM'} | ${recording.quality || '720p'}`;
                
                // Mini thumbnail (not clickable)
                let thumbnailHtml = '';
                if (recording.screenshot) {
                    thumbnailHtml = `
                        <img src="${recording.screenshot}" 
                             alt="Recording thumbnail" 
                             class="thumbnail-image"
                             title="Recording preview">
                    `;
                }
                
                recordingDiv.innerHTML = `
                    <div class="recording-item-content">
                        ${thumbnailHtml}
                        <div class="recording-item-info">
                            <div class="recording-name">${recording.filename}</div>
                            <div class="recording-details">
                                ${sizeInMB} MB • ${formatTime(recording.duration || 0)} • ${date} • ${sourceInfo}
                            </div>
                        </div>
                    </div>
                    <div class="recording-item-actions">
                        <button class="rename-btn" onclick="renameRecording(${recordings.length - 1 - index})" title="Rename this recording">
                            Rename file
                        </button>
                        <button class="download-btn" onclick="downloadRecording(${recordings.length - 1 - index})">
                            Download
                        </button>
                        <button class="download-btn delete-btn" onclick="deleteRecording(${recordings.length - 1 - index})">
                            Delete
                        </button>
                    </div>
                `;
                
                recordingsList.appendChild(recordingDiv);
            });
        }

        function renameRecording(index) {
            const recordings = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.RECORDINGS) || '[]');
            const recording = recordings[index];
            
            if (!recording) {
                stateManager.showAlert('Recording not found', 'error');
                return;
            }
            
            // Get current filename without extension
            const currentName = recording.filename.replace(/\.[^/.]+$/, '');
            
            // Prompt user for new name
            const newName = prompt('Enter new filename (without extension):', currentName);
            
            if (newName && newName.trim() && newName.trim() !== currentName) {
                // Clean the new name (remove special characters)
                const cleanName = newName.trim().replace(/[^a-zA-Z0-9_-]/g, '_');
                
                if (cleanName) {
                    // Get file extension from original filename
                    const extension = recording.filename.split('.').pop();
                    const newFilename = `${cleanName}.${extension}`;
                    
                    // Update the recording
                    recording.filename = newFilename;
                    recordings[index] = recording;
                    
                    // Save back to localStorage
                    localStorage.setItem(CONFIG.STORAGE_KEYS.RECORDINGS, JSON.stringify(recordings));
                    
                    // Refresh the list
                    loadSavedRecordings();
                    
                    stateManager.showAlert(`Recording renamed to: ${newFilename}`);
                } else {
                    stateManager.showAlert('Invalid filename. Please use only letters, numbers, underscores, and hyphens.', 'error');
                }
            }
        }

        function downloadRecording(index) {
            const recordings = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.RECORDINGS) || '[]');
            const recording = recordings[index];
            
            if (recording) {
                try {
                    const a = document.createElement('a');
                    a.href = recording.data;
                    a.download = recording.filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    stateManager.showAlert('Video download started');
                } catch (error) {
                    console.error('Download failed:', error);
                    stateManager.showAlert('Download failed', 'error');
                }
            }
        }



        function deleteRecording(index) {
            const recordings = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.RECORDINGS) || '[]');
            recordings.splice(index, 1);
            localStorage.setItem(CONFIG.STORAGE_KEYS.RECORDINGS, JSON.stringify(recordings));
            loadSavedRecordings();
            stateManager.showAlert('Recording deleted');
        }



        // INITIALIZE GLOBAL STATE
        const stateManager = new RecordingStateManager();
        const thumbnailEngine = new ThumbnailCaptureEngine(stateManager);

        // ADD captureFinalThumbnail METHOD TO THUMBNAIL ENGINE
        ThumbnailCaptureEngine.prototype.captureFinalThumbnail = function(recordingId) {
            const captureData = this.stateManager.thumbnailCaptures.get(recordingId);
            if (!captureData || !captureData.video) return null;
            
            try {
                const { video } = captureData;
                if (video.videoWidth > 0 && video.videoHeight > 0) {
                    this.canvas.width = CONFIG.THUMBNAIL_DIMENSIONS.WIDTH;
                    this.canvas.height = CONFIG.THUMBNAIL_DIMENSIONS.HEIGHT;

                    const videoAspect = video.videoWidth / video.videoHeight;
                    const canvasAspect = this.canvas.width / this.canvas.height;
                    let sx = 0, sy = 0, sw = video.videoWidth, sh = video.videoHeight;
                    
                    if (videoAspect > canvasAspect) {
                        sw = video.videoHeight * canvasAspect;
                        sx = (video.videoWidth - sw) / 2;
                    } else {
                        sh = video.videoWidth / canvasAspect;
                        sy = (video.videoHeight - sh) / 2;
                    }

                    this.ctx.fillStyle = '#000000';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.drawImage(video, sx, sy, sw, sh, 0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    const thumbnail = this.canvas.toDataURL('image/jpeg', 0.8);

                    const recording = this.stateManager.screenRecordings.get(recordingId);
                    if (recording) {
                        recording.screenshot = thumbnail;
                    }
                    captureData.lastCapture = thumbnail;
                    return thumbnail;
                }
            } catch (e) {
                console.warn('captureFinalThumbnail error:', e);
            }
            return null;
        };

        // LOAD SAVED RECORDINGS ON PAGE LOAD
        document.addEventListener('DOMContentLoaded', function() {
            loadSavedRecordings();
            
            // Quality slider functionality
            const qualitySlider = document.getElementById('video-quality');
            const qualityText = document.getElementById('quality-text');
            
            const qualityNames = ['4K Ultra', '1440p QHD', '1080p Full HD', '720p HD', '480p SD'];
            
            function updateQualityDisplay(value) {
                if (qualityText) {
                    qualityText.textContent = qualityNames[value] || '4K Ultra';
                }
            }
            
            if (qualitySlider) {
                qualitySlider.addEventListener('input', function() {
                    updateQualityDisplay(this.value);
                });
                
                // Initialize display
                updateQualityDisplay(qualitySlider.value);
            }
        });
    </script>
</body>
</html>